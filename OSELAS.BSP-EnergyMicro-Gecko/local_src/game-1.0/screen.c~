
#include <sys/stat.h>

#include <sys/ioctl.h>
#include <signal.h>
#include "screen.h"

//#define FILEPATH "/dev/fb0"
#define GAMEPAD "/dev/gamepad"


struct fb_copyarea rect;
struct fb_var_screeninfo vinfo;
struct fb_fix_screeninfo finfo;

int lastButtonPressed = -1;

FILE* gamepad;

void init_gamepad();

/* la oss lage et 8x8 rutenett som dekker hele skjermen. Vi bruker to forskjellige farger. Hver brikketype har en enkel form (en tilfeldig sammensetning av piksler som representerer hver brikke). Hver brikke er angitt med en "offset" adresse relativt til en blokk ( relativ addresse angitt innenfor en range av høyde/8, bredde/8). Offset adressen blir da konstant, og den totale adressen vil da bare være en utskrift av 8x8 matrisen.*/
/*int main(int argc, char *argv[])
  {
  int fd = open(FILEPATH, O_RDWR);
  if (fd == -1) {
  perror("Error opening file for reading");
  exit(EXIT_FAILURE);
  }

  short* map = mmap(0, FILESIZE, PROT_WRITE, MAP_SHARED, fd, 0);

  screenclear(map,fd); 
  drawboard(map, fd);

  munmap(map,FILESIZE);

  init_gamepad();
  while(1) pause();

  exit(EXIT_SUCCESS);
  }*/
//insert a dynamic allocated array right here to writeback the vlaue from the button 
void button_handler(int signo)
{
    int raw_input = fgetc(gamepad);
    int button = 1;

    while (raw_input > 1) {
        raw_input >>= 1;
        button++;
    }

    lastButtonPressed = button;

    printf("button %d\n", button);

}

int getLastButtonPressed() {
    int toReturn = lastButtonPressed;
    lastButtonPressed = -1;
    return toReturn;
}

void init_gamepad()
{
    gamepad = fopen(GAMEPAD, "rb");
    signal(SIGIO, &button_handler);
    fcntl(fileno(gamepad), F_SETOWN, getpid());
    long oflags = fcntl(fileno(gamepad), F_GETFL);
    fcntl(fileno(gamepad), F_SETFL, oflags | FASYNC);
    printf("gamepad initialized\n");
}

int screenclear(short* map, int fd)
{
    //legg til try/catch eller noe
    rect.dx=0;
    rect.dy=0;
    rect.width=319;
    rect.height=239;
    long i=1;
    long j=1;
    while(i<=239) {
        j=1;
        while(j<=319) {
            *(map+i*320+j)=0x0000;
            j++;
        }

        i++;
    }
    ioctl(fd, 0x4680, &rect);
    return 0;
}

int drawboard(short* map, int fd)
{
    rect.dx = 0;
    rect.dy = 0;
    rect.width = 240;
    rect.height = 240;
    int i, j, r, c;
    short color;
    for (i = 0; i < 240; i++) {
        for (j = 0; j < 240; j++) {
            r = i / 30;
            c = j / 30;
            color = (r%2) == (c%2) ? 0x000F : 0x0006;
            *(map+i*320+j) = color;
        }
    }
    ioctl(fd, 0x4680, &rect);
    return 0;
}

void squareclear(short* map, int fd, int col, int row)
{
    //rect.dx = 0;
    // rect.dy = 0;
    // rect.width = 240;
    //rect.height = 240;
    //optimization vs robustness: we can specify the exact square where we need to update using the variables above. However this may decrease robustness by introdusing artifacts on screen
    int  r, c;
    long i=320*30*(7-row);
    long j=30*(col);
    short boardcolor;
    r = i / 30;
    c = j / 30;
    boardcolor = (row%2) == (col%2) ? 0x0006 : 0x000f;
    for(; i<320*30*(7-row+1); i+=320)
    {
        for(j=30*col; j<30*(col+1); j++) {
            *(map+i+j) = boardcolor;
        }
    }
    ioctl(fd, 0x4680, &rect);



}

int* getPictureForType(pieceType type)
{
    int pic[];
    switch (type) {
        case BISHOP:
            pic = {
                0
                0,
                0,
                49152,
                122880,
                49152,
                49152,
                258048,
                522240,
                1047552,
                2047488,
                1973760,
                2047488,
                4144896,
                2096640,
                2096640,
                789504,
                522240,
                264192,
                1047552,
                258048,
                16777152,
                33505248,
                33431520,
                0,
                0,
                0,
                0
            }; break;
        case ROOK:
            pic = {
                0
                0,
                0,
                0,
                0,
                2671872,
                3794688,
                4194048,
                4194048,
                4194048,
                2096640,
                525312,
                1047552,
                1047552,
                1047552,
                1047552,
                2096640,
                2096640,
                2096640,
                1049088,
                4194048,
                8388480,
                8388480,
                8388480,
                0,
                0,
                0,
                0
            }; break;
        case KING:
            pic = {
                0
                0,
                0,
                0,
                49152,
                122880,
                49152,
                49152,
                7915392,
                13056192,
                20108064,
                58271648,
                41758608,
                41869200,
                58646448,
                25042848,
                29310816,
                14556864,
                6291840,
                4194048,
                4144896,
                3144960,
                2146560,
                4194048,
                0,
                0,
                0,
                0
            }; break;


        case QUEEN:
            pic = {
                0
                0,
                0,
                0,
                0,
                924672,
                924672,
                924672,
                399360,
                924672,
                59718768,
                59718768,
                26213472,
                16777152,
                8388480,
                8388480,
                4194048,
                4194048,
                3146496,
                3668736,
                2047488,
                3619584,
                3146496,
                4194048,
                0,
                0,
                0,
                0
            }; break;
        case KNIGHT:
            pic = {
                0
                0,
                0,
                0,
                8192,
                28672,
                129024,
                261120,
                491008,
                1998080,
                4193920,
                16776832,
                14677696,
                16772672,
                16772672,
                3939904,
                7405120,
                261824,
                523968,
                1048256,
                2096832,
                2097088,
                2097088,
                2097088,
                0,
                0,
                0,
                0
            }; break;
        case PAWN:
            pic = {
                0
                0,
                0,
                0,
                0,
                0,
                122880,
                258048,
                258048,
                258048,
                258048,
                122880,
                522240,
                1047552,
                122880,
                122880,
                258048,
                258048,
                522240,
                522240,
                1047552,
                4194048,
                4194048,
                4194048,
                0,
                0,
                0,
                0
            }; break;
        case EMPTY:
            pic = {
                0,0,0,0,0,0,0,0,0,0,0,0,0,
                0,0,0,0,0,0,0,0,0,0,0,0,0,
            }; break;
    }

    return pic;
}

void printpiece(short* map, int fd, pieceType type, colorType color, int col, int row)
{
    short piececolor;
    short clearcolor;
    int x,y;
    int[] picture = getPictureForType(type);
    piececolor = (color == BLACK) ? 0xabcd : 0xa215;//change color
    cleacolor = (row%2) == (col%2) ? 0x0006 : 0x000f;
    for (y = 0; y < 30; y++)
    {
        for (x = 0; x < 30; x++)
        {
           *(map + 30*320*(7-row+y) + 30*col+x) 
               = (picture[y] & (1 << x) > 0) ? piececolor : clearcolor;  
        }
    }
}

void printpieceKing(short* map, int fd, colorType color, int col, int row)
{
    //rect.dx = 0;
    // rect.dy = 0;
    // rect.width = 240;
    //rect.height = 240;
    //need to take 7-row for each piece else the output on the screen get upside down
    long i=320*30*(7-row);
    long j=30*(col);
    short boardcolor;
    boardcolor = (color == BLACK) ? 0xabcd : 0xa215;//change color
    for(; i<320*30*(7-row+1); i+=320)
    {
        for(j=30*col; j<30*(col+1); j++)//insert kewl patterns with i and j to create figures
        {

            *(map+i+j) = boardcolor;
        }
    }
    ioctl(fd, 0x4680, &rect);
}
void printpieceQueen(short* map, int fd, colorType color, int col, int row)
{
    //rect.dx = 0;
    // rect.dy = 0;
    // rect.width = 240;
    //rect.height = 240;
    long i=320*30*(7-row);
    long j=30*col;
    short boardcolor;
    boardcolor = (color == BLACK) ? 0xdefa : 0x5432;//change color
    for(; i<320*30*(7-row+1); i+=320)
    {
        for(j=30*col; j<30*(col+1); j++)//insert kewl patterns with i and j to create figures
        {

            *(map+i+j) = boardcolor;
        }
    }
    ioctl(fd, 0x4680, &rect);

}
void printpieceKnight(short* map, int fd, colorType color, int col, int row)
{
    //rect.dx = 0;
    // rect.dy = 0;
    // rect.width = 240;
    //rect.height = 240;
    long i=320*30*(7-row);
    long j=30*col;
    short boardcolor;
    boardcolor = (color == BLACK) ? 0xbaad : 0x0246;//change color
    for(; i<320*30*(7-row+1); i+=320)
    {
        for(j=30*col; j<30*(col+1); j++)//insert kewl patterns with i and j to create figures
        {

            *(map+i+j) = boardcolor;
        }
    }
    ioctl(fd, 0x4680, &rect);

}
void printpieceBishop(short* map, int fd, colorType color, int col, int row)
{
    //rect.dx = 0;
    // rect.dy = 0;
    // rect.width = 240;
    //rect.height = 240;
    long i=320*30*(7-row);
    long j=30*col;
    short boardcolor;
    boardcolor = (color == BLACK) ? 0x9afd : 0x6420;//change color
    for(; i<320*30*(7-row+1); i+=320)
    {
        for(j=30*col; j<30*(col+1); j++)//insert kewl patterns with i and j to create figures
        {

            *(map+i+j) = boardcolor;
        }
    }
    ioctl(fd, 0x4680, &rect);

}
void printpieceRook(short* map, int fd, colorType color, int col, int row)
{
    //rect.dx = 0;
    // rect.dy = 0;
    // rect.width = 240;
    //rect.height = 240;
    long i=320*30*(7-row);
    long j=30*col;
    short boardcolor;
    boardcolor = (color == BLACK) ? 0xfade : 0x4246;//change color
    for(; i<320*30*(7-row+1); i+=320)
    {
        for(j=30*col; j<30*(col+1); j++)//insert kewl patterns with i and j to create figures
        {

            *(map+i+j) = boardcolor;
        }
    }
    ioctl(fd, 0x4680, &rect);

}
void printpiecePawn(short* map, int fd, colorType color, int col, int row)
{
    //rect.dx = 0;
    // rect.dy = 0;
    // rect.width = 240;
    //rect.height = 240;
    long i=320*30*(7-row);
    long j=30*col;
    short boardcolor;
    boardcolor = (color == BLACK) ? 0xdaea : 0x1427;//change color
    for(; i<320*30*(7-row+1); i+=320)
    {
        for(j=30*col; j<30*(col+1); j++)//insert kewl patterns with i and j to create figures
        {

            *(map+i+j) = boardcolor;
        }
    }
    ioctl(fd, 0x4680, &rect);

}


